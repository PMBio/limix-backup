I will try to put in order of importance, from my point of view.

1. We need unit tests, implemented and organized in such a way that we can
quickly run subsets of tests. For ex., "I want to run all covariance tests",
or "I want to run all tests" or "I want to run the test for this specific
class." We can do this by using unittest and the discover option:
python -m unittest discover ./core/covar
I think having nice unit tests is a must-have in order for other people to
both understand how to use your classes (the tests work as usage examples)
and to avoid breaking the code.

2. We should be able to run any script (which includes unit tests and files
with the "if __name__ == '__main__'" trick) from any folder: Ex.: My current
working directory could be /Users/horta/something/ and I should be able to
do "python ~/workspace/limix/limix/core/covar/linear.py".
This implies that we should never mess with environment variables such
as the PATH one (ex.,
  import sys
  sys.path.insert(0,'./../../..'),
  with the idea of correcting a flawed and specific environment). You never
know what is the working directory the user will be using. This can also lead to
cardiac arrhythmia in other programmers, and even sudden death in some cases.

3. Testing and tested code have to live far from each other, which means that
the testing part should not influence the tested part. I.e., don't implement
a method in a tested class in order to provide a functionality for the
testing class. This leads to more errors instead of less.

4. Importing everything from a module should be avoided at (almost) any cost.
This: from limix.core.utils.eigen import *
It does not matter that it requires 10 lines in order to import the names
you want. It is well-known that most of programmer's time is spent reading
the code, and not writing it. So the priority has to be "easy-to-read"
instead of saving keyboard key strokes. When I read
"from limix.core.utils.eigen import *", I really don't know what you are
importing, and forces me to go and read the eigen module implementation
in order to find out.

5. Names should be meaningful (Ideally. I know that sometimes naming it
v1, v2, helps..., when the only use of those variables is in the next line...).
For ex., cobj.py is a bad name because it does not convey the important
information that this file is all about caching. Also cObject is not a good
name for the same reason...

6. There are several rules of thumb among the programmer's community, broadly
applied to good code. For ex., class names should be capitalized (only the
starting letter, or in a cammelcase style, or whatever). Writing a class
named 'gp' will cause conflicts later on when somebody wants to use a variable
named 'gp' (and every programmer will assume that 'gp' for a variable name
would not be harmful). So the right way would be to name it GP or Gp
(I prefer the first).

7. Do not commit IDE files or any other file that is related to your environment
specifically.

8. There are some standard labels for broadly used python libraries. For ex.:

import numpy as np
import scipy as sp
import matplotlib as mpl
import pylab as plt

Why not adopt the same style?

9. Forthesamereasonweusespacesbetweenwordsinatext,weshouldalsodosointhecode.

10. Try to avoid repeating yourself:

core/gp/gp_base.py could be written core/gp/base.py

But I understand that sometimes repeating yourself is good for remembering
purposes or clarity... However, remember that (usually) the names to be exported
from a package (e.g., covar is a package, gp is a package) should (ideally)
appear in the __init__.py. Example:

Suppose, for example, that in the package covar you created a class
named Base, and suppose that you want to export that name. You can do the
following in __init__.py:

from base import Base as CovarBase

So everyone else will see the nice and clear CovarBase, and I can do from
outside:

from limix.core.covar import CovarBase
